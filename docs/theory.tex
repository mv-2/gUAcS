\documentclass{article}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{siunitx}
\usepackage{tikz}
\usepackage{booktabs}
\usepackage{bm}
\usepackage{xcolor}
\usepackage[margin=0.75in]{geometry}
\usepackage[calc, showdow,english]{datetime2}
\usepackage[backend=biber, style=ieee]{biblatex}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\addbibresource{references.bib}

\algnewcommand{\Initialise}[1]{
  \State \textbf{Initialise:}
  \Statex \hspace*{\algorithmicindent}\parbox[t]{.8\linewidth}{\raggedright #1}
}

\DTMnewdatestyle{mydateformat}{
  \renewcommand{\DTMdisplaydate}[4]{
    \DTMshortweekdayname{##4},\space
    \DTMmonthname{##2}\nobreakspace
    \number##3,\space
    \number##1
  }
  \renewcommand{\DTMDisplaydate}{\DTMdisplaydate}%
}

\title{Underwater Acoustic Simulation Theory}
\author{mv-2}
\date{\today}

\begin{document}
\maketitle
\tableofcontents
\clearpage

\section{Background \& Motivation}
This project is intended as a learning exercise for both the physics of sound propagation and the programming aspects required for this project. \\
The intended theory to be explored is initially to develop ray propagation simulation based on repeated application of Snell's law and then to layer on Gaussian Beam Tracing (GBT) to eventually develop a well rounded sound prediction tool for higher frequency acoustics. If this is successful, a nodal based solver for low frequency noise will be developed although this would be a large undertaking and is a stretch goal at this time.

\section{Geometric Ray Tracing}
\subsection{Physical Theory}
The geometric ray trace theory used in this simulation is based on work from \textcite{Hovem13}. This methodology discretises the sound speed profile into evenly spaced layers and applies Snell's law (Equation \ref{eq:snell}) across each layer in order to determine the ray path. 
\begin{equation}
  \label{eq:snell}
  \frac{\sin{(\theta_1)}}{\sin{(\theta_2)}}=\frac{c_1}{c_2}
\end{equation}
By assuming that the ray is only refracted between all fluid layers across the entire solution space then this relationship can be reduced to the parameter $\xi$ as shown in Equation \ref{eq:ray_param}.
\begin{align}
  \label{eq:ray_param}
  \xi = \frac{\cos{(\theta(z))}}{c(z)} = \frac{\cos{(\theta_0)}}{c_0}
\end{align}
For a full derivation see \textcite{Hovem13}. For the purposes of the acoustic simulation, Equations \ref{eq:dr_int} and \ref{eq:dt_int} are required.
\begin{equation}
  \label{eq:dr_int}
  \Delta r = \int^{z_2}_{z_1}\frac{\xi c(z)}{\sqrt{1-\xi^2\cdot c^2(z)}}dz
\end{equation}
\begin{equation}
  \label{eq:dt_int}
  \Delta t = \int^{z_2}_{z_1}\frac{1}{c(z)\sqrt{1-\xi^2\cdot c^2(z)}}dz
\end{equation}
To compute these intervals the function for $c(z)$ must be known. Based on the form of the integrals in Equations \ref{eq:dr_int} and \ref{eq:dt_int} not all function forms allow for the integrals to be solved analytically. The most obvious and consequently useful form of $c(z)$ is to assume it is a set of piecewise linear functions along each layer of the fluid medium. Assuming that a general function is known for $c(z)$ either analytically or from curve fitting then the fluid layer $i$ should have the form shown in Equation \ref{eq:layer_lin}.
\begin{equation}
  \label{eq:layer_lin}
  \begin{split}
    c_i(z) = c_i+g_i\cdot(z-z_i),\;\mathrm{for}\;z\in[z_i, z_{i+1}) \\
    \mathrm{where}\;g_i=\frac{c_{i+1}-c_{i}}{\Delta z}
  \end{split}  
\end{equation}
Solving the integrals with this form of sound speed profile leads to the relationships shown in Equations \ref{eq:dr} and \ref{eq:dt}.
\begin{equation}
  \label{eq:dr}
  \Delta r = \frac{\sqrt{1-\xi^2\cdot c^2(z_i)} - \sqrt{1-\xi^2\cdot c^2(z_{i+1})}}{\xi\cdot g_i}
\end{equation}

\begin{equation}
  \label{eq:dt}
  \Delta t = \frac{\ln{\left( \frac{c(z_{i+1})}{c(z_i)}\frac{1 + \sqrt{1 - \xi^2\cdot c^2(z_i)}}{1 + \sqrt{1 - \xi^2\cdot c^2(z_{i+1})}} \right)}}{|g_i|}
\end{equation}
Note that upon inspection of these equations it is clear that if the term $\xi\cdot c(z_{j})\geq 1$ then the equations will both return imaginary quantities. This is non-physical behaviour and must be handled as an edge case. If the increment in range or time is imaginary then it can be concluded that the ray does not reach the next layer of the fluid medium and instead reverses depth direction and $z_{i+1}=z_i$. This lays the groundwork for the ray tracing algorithms although some extra details need to be considered such as how the sound speed profile is to be expressed and other programmatic elements.

\subsection{Ray Tracing Algorithm}
The generic ray tracing algorithm is included below in Algorithm \ref{alg:ray}.
\begin{algorithm}
  \caption{Ray tracing algorithm}\label{alg:ray}
  \begin{algorithmic}
    \Initialise{\strut$r_0\gets \mathrm{source range}$ \\$z_0\gets \mathrm{source depth}$ \\$\theta_0\gets \mathrm{source ray angle}$ \\$z_{\mathrm{sign}}=\mathrm{sign}(\sin(\theta_0))$ \\$i\gets 0$ \\$t\gets 0$\\$maximum iterations$}
    \State $c_0\gets c(z_0)$, $c_1\gets c(z_0+z_{\mathrm{sign}}\cdot\Delta z)$
    \State $\xi\gets \frac{\cos(\theta_0)}{c_0}$
    \While{$i<\textrm{max\;\; iterations}$}
      \State $g_i=\frac{c_{i+1} - c_i}{\Delta z}$
      \If {$\xi\cdot g_i < 1$}
        \State $\Delta r = \frac{\sqrt{1-\xi^2\cdot c^2(z_i)} - \sqrt{1-\xi^2\cdot c^2(z_{i+1})}}{\xi\cdot g_i}$ 
        \State $\Delta t = \frac{\ln{\left( \frac{c(z_{i+1})}{c(z_i)}\frac{1 + \sqrt{1 - \xi^2\cdot c^2(z_i)}}{1 + \sqrt{1 - \xi^2\cdot c^2(z_{i+1})}} \right)}}{|g_i|}$
        \State $z_{i+1}\gets z_i+z_{\mathrm{sign}}\cdot\Delta z$
      \Else
        \State $\Delta r=\frac{2\cdot\sqrt{1-\xi^2\cdot c^2(z_i)}}{\xi\cdot g_i}$
        \State $\Delta t=\frac{2\cdot\ln{(\frac{1 + \sqrt{1-\xi^2\cdot c^2(z_i)}}{\xi\cdot c(z_i)})}}{|g_i|}$
        \State $z_{\mathrm{sign}}\gets-z_{\mathrm{sign}}$
      \EndIf
      \State $r_{i+1} \gets r_i + \Delta r$
      \State $t_{i+1}\gets t_i+\Delta t$
      \State $i\gets i+1$
    \EndWhile
    \Return $\bm{r}, \bm{z}, \bm{t}$
  \end{algorithmic}
\end{algorithm}

\subsection{Reflection}
In order to accurately model reflection of rays two problems must be handled. Firstly, the point of intersection between a ray and an object must be accurately calculated and then the entry and exit angles of the ray can be calculated as needed.  

\subsubsection{Body Intersection}
Within the \texttt{gUAcS} software package, bodies are all defined as polygons. This means intersection between a ray and polygonal body can be calculated by determining the location at which the line defined by a ray and each side of the polygon meet in order to determine a valid intersection.
\\
Consider the line $l_i$ defined by the two points $(r_{i, 0}, z_{i, 0}), (r_{i, 1}, z_{i, 1})$. Now determine the intersection between the lines $l_{ray}$ and $l_{edge}$.
\begin{align*}
  l_{ray}:&\; \bm{p}_{ray, 0}=(r_{ray, 0}, z_{ray, 0}), \bm{p}_{ray, 1}=(r_{ray, 1}, z_{ray, 1}) \\
  l_{edge}:&\; \bm{p}_{edge, 0}=(r_{edge, 0}, z_{edge, 0}), \bm{p}_{edge, 1}=(r_{edge, 1}, z_{edge, 1}) \\
\end{align*}
Parameterise the lines $l_{ray}$ and $l_{edge}$ and consider for our case a ray will only propagate forwards and the side of the polygon must lie between the points used to define it. This means constraints can be imposed on $t$ and $\tau$ in order to determine when valid intersections are made. 
\begin{align*}
  l_{ray}:&\; \bm{p}(t)= \bm{p}_{ray, 0} + t\cdot(\bm{p}_{ray, 1} - \bm{p}_{ray, 0}),\;\;\mathrm{for}\;t\geq0\\
  l_{edge}:&\; \bm{p}(\tau)= \bm{p}_{edge, 0} + \tau\cdot(\bm{p}_{edge, 1} - \bm{p}_{edge, 0}),\;\;\mathrm{for}\;\tau\in[0, 1]\\
\end{align*}
By setting $\bm{p}(t)=\bm{p}(\tau)$ a point of intersection can be calculated.
\begin{align*}
  \bm{p}_{edge, 0} + \tau\cdot(\bm{p}_{edge, 1} - \bm{p}_{edge, 0}) = & \bm{p}_{ray, 0} + t\cdot(\bm{p}_{ray, 1} - \bm{p}_{ray, 0})\\
  \begin{bmatrix} r_{edge, 0} \\ z_{edge, 0} \end{bmatrix} + \tau\cdot\left(\begin{bmatrix} r_{edge, 1} \\ z_{edge, 1} \end{bmatrix}  -  \begin{bmatrix} r_{edge, 0} \\ z_{edge, 0} \end{bmatrix} \right) = & \begin{bmatrix} r_{ray, 0} \\ z_{ray, 0} \end{bmatrix} + t\cdot\left(\begin{bmatrix} r_{ray, 1} \\ z_{ray, 1} \end{bmatrix}  -  \begin{bmatrix} r_{ray, 0} \\ z_{ray, 0} \end{bmatrix} \right)\\
  \begin{bmatrix} r_{edge, 0} + \tau\cdot(r_{edge, 1} - r_{edge, 0}) \\ z_{edge, 0} + \tau\cdot(z_{edge, 1} - z_{edge, 0}) \end{bmatrix} = & \begin{bmatrix} r_{ray, 0} + t\cdot(r_{ray, 1} - r_{ray, 0}) \\ z_{ray, 0} + t\cdot(z_{ray, 1} - z_{ray, 0}) \end{bmatrix}
\end{align*}
Now split into equations for $x$ and $y$.
\begin{align*}
  r_{edge, 0} - r_{ray, 0} + \tau\cdot(r_{edge, 1} - r_{edge, 0}) = t\cdot (r_{ray, 1} - r_{ray, 0})\\
  \implies t = \frac{ r_{edge, 0} - r_{ray, 0} + \tau\cdot(r_{edge, 1} - r_{edge, 0})}{r_{ray, 1} - r_{ray, 0}} \\
  z_{edge, 0} - z_{ray, 0} + \tau\cdot(z_{edge, 1} - z_{edge, 0}) = t\cdot (z_{ray, 1} - z_{ray, 0})\\
  \implies t = \frac{ z_{edge, 0} - z_{ray, 0} + \tau\cdot(z_{edge, 1} - z_{edge, 0})}{z_{ray, 1} - z_{ray, 0}} \\
  \implies  \frac{ r_{edge, 0} - r_{ray, 0} + \tau\cdot(r_{edge, 1} - r_{edge, 0})}{r_{ray, 1} - r_{ray, 0}} = \frac{ z_{edge, 0} - z_{ray, 0} + \tau\cdot(z_{edge, 1} - z_{edge, 1})}{z_{ray, 1} - z_{ray, 0}} \\ 
  \frac{r_{edge, 0} - r_{ray, 0}}{r_{ray, 1} - r_{ray, 0}} - \frac{z_{edge, 0} - z_{ray, 0}}{z_{ray, 1} -z_{ray, 0}} = \tau\cdot\left(\frac{z_{edge, 1} - z_{edge, 0}}{z_{ray, 1} - z_{ray, 0}} - \frac{r_{edge, 1} - r_{edge, 0}}{r_{ray, 1} - r_{ray, 0}}\right)\\
\frac{(r_{edge, 0} - r_{ray, 0})\cdot(z_{ray, 1} - z_{ray, 0}) - (z_{edge, 0} - z_{ray, 0})\cdot(r_{ray, 1} - r_{ray, 0})}{(r_{ray, 1} - r_{ray, 0})(z_{ray, 1} - z_{ray, 0})} = \\ \tau\cdot\left(\frac{(z_{edge, 1} - z_{edge, 0})\cdot(r_{ray, 1} - r_{ray, 0}) - (r_{edge, 1} - r_{edge, 0})\cdot(z_{ray, 1} - z_{ray, 0})}{(r_{ray, 1} - r_{ray, 0})(z_{ray, 1} - z_{ray, 0})}\right) \\
\end{align*}
\begin{equation}
  \label{eq:edge_dist}
\therefore \tau = \frac{(r_{edge, 0} - r_{ray, 0})\cdot(z_{ray, 1} - z_{ray, 0}) - (z_{edge, 0} - z_{ray, 0})\cdot(r_{ray, 1} - r_{ray, 0})}{(z_{edge, 1} - z_{edge, 0})\cdot(r_{ray, 1} - r_{ray, 0}) - (r_{edge, 1} - r_{edge, 0})\cdot(z_{ray, 1} - z_{ray, 0})}
\end{equation}
\begin{equation}
  \label{eq:ray_dist}
  t = \frac{ z_{edge, 0} - z_{ray, 0} + \tau\cdot(z_{edge, 1} - z_{edge, 0})}{z_{ray, 1} - z_{ray, 0}}
\end{equation}
Equation \ref{eq:edge_dist} can be used to directly calculate $\tau$ and by extension $t$ can then be calculated from Equation \ref{eq:ray_dist}. Note that in this form of the equation if both the direction of the edge and the ray is the same such that $\Delta r_{edge} = k\cdot\Delta r_{ray}$ and $\Delta z_{edge} = k\cdot\Delta z_{ray}$ for $k\in\mathbb{R}$ then the denominator of this equations tends to $0$ resulting in an undefined result. This makes intuitive sense as there should be no solution for parallel lines having a point of intersection. As stated above the calculated intersection is valid if and only if $t\geq0$ and $\tau\in[0, 1]$. 

\subsubsection{Reflection Angle}

\section{General Functions}
\subsection{Sound Speed Profile Representation}
The sound speed profile is treated as range invariant in the current \texttt{gUAcS} package. The profile is expressed as the knots, coefficients and degree of a B-spline within the configuration files for the program. This requires the B-spline to be evaluated at each depth point for the program. To do so De Boor's Algorithm is implemented where; $\{c_{i}\}$ is the set of spline coefficients, $\{t_{i}\}$ is the set of spline knots and $p$ is the order of the spline. The algorithm is shown below in Algorithm \ref{alg:deboor}.
\begin{algorithm}[H]
  \caption{De Boor's Algorithm}\label{alg:deboor}
  \begin{algorithmic}
    \Initialise{$x$}
    \State $k\gets i$ for which $i$ satisfies $t_{i} > x$ and $t_{i-1} \leq x$
    \State $d_i\gets c_{j + k -order}$ for $j\in{0,1,...,p}$
    \For{$r\gets 1$ to $p$}
      \For{$j\gets p$ to $r$} 
        \State $i\gets j + k - p$
        \State $\alpha_j = \frac{x - t_i}{t_{j + 1 + k - r} - t_{i}}$
        \State $d_j = (1 - \alpha_j)\cdot d_{j-1} + \alpha_j\cdot d_{j}$
      \EndFor
    \EndFor
    \Return $d_{p}$
  \end{algorithmic}
\end{algorithm}


\nocite{*}
\printbibliography

\end{document}
